<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://github.com/facebook/regenerator">regenerator (v0.9.7)</a>
</h1>
<h4>Source transformer enabling ECMAScript 6 generator functions (yield) in JavaScript-of-today (ES5)</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.regenerator">module regenerator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.regenerator">
            function <span class="apidocSignatureSpan"></span>regenerator
            <span class="apidocSignatureSpan">(file, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.compile">
            function <span class="apidocSignatureSpan">regenerator.</span>compile
            <span class="apidocSignatureSpan">(source, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.runtime">
            function <span class="apidocSignatureSpan">regenerator.</span>runtime
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.transform">
            function <span class="apidocSignatureSpan">regenerator.</span>transform
            <span class="apidocSignatureSpan">(node, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.NodePath">
            function <span class="apidocSignatureSpan">regenerator.</span>types.NodePath
            <span class="apidocSignatureSpan">(value, parentPath, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Path">
            function <span class="apidocSignatureSpan">regenerator.</span>types.Path
            <span class="apidocSignatureSpan">(value, parentPath, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.PathVisitor">
            function <span class="apidocSignatureSpan">regenerator.</span>types.PathVisitor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Type">
            function <span class="apidocSignatureSpan">regenerator.</span>types.Type
            <span class="apidocSignatureSpan">(check, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.astNodesAreEquivalent">
            function <span class="apidocSignatureSpan">regenerator.</span>types.astNodesAreEquivalent
            <span class="apidocSignatureSpan">(a, b, problemPath)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regenerator.</span>types</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regenerator.</span>types.NodePath.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regenerator.</span>types.Path.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regenerator.</span>types.PathVisitor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regenerator.</span>types.Type.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regenerator.</span>types.builders</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regenerator.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regenerator.</span>visit</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regenerator.runtime">module regenerator.runtime</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.runtime.AsyncIterator">
            function <span class="apidocSignatureSpan">regenerator.runtime.</span>AsyncIterator
            <span class="apidocSignatureSpan">(generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.runtime.async">
            function <span class="apidocSignatureSpan">regenerator.runtime.</span>async
            <span class="apidocSignatureSpan">(innerFn, outerFn, self, tryLocsList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.runtime.awrap">
            function <span class="apidocSignatureSpan">regenerator.runtime.</span>awrap
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.runtime.isGeneratorFunction">
            function <span class="apidocSignatureSpan">regenerator.runtime.</span>isGeneratorFunction
            <span class="apidocSignatureSpan">(genFun)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.runtime.keys">
            function <span class="apidocSignatureSpan">regenerator.runtime.</span>keys
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.runtime.mark">
            function <span class="apidocSignatureSpan">regenerator.runtime.</span>mark
            <span class="apidocSignatureSpan">(genFun)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.runtime.values">
            function <span class="apidocSignatureSpan">regenerator.runtime.</span>values
            <span class="apidocSignatureSpan">(iterable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.runtime.wrap">
            function <span class="apidocSignatureSpan">regenerator.runtime.</span>wrap
            <span class="apidocSignatureSpan">(innerFn, outerFn, self, tryLocsList)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regenerator.types">module regenerator.types</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.NodePath">
            function <span class="apidocSignatureSpan">regenerator.types.</span>NodePath
            <span class="apidocSignatureSpan">(value, parentPath, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Path">
            function <span class="apidocSignatureSpan">regenerator.types.</span>Path
            <span class="apidocSignatureSpan">(value, parentPath, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.PathVisitor">
            function <span class="apidocSignatureSpan">regenerator.types.</span>PathVisitor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Type">
            function <span class="apidocSignatureSpan">regenerator.types.</span>Type
            <span class="apidocSignatureSpan">(check, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.astNodesAreEquivalent">
            function <span class="apidocSignatureSpan">regenerator.types.</span>astNodesAreEquivalent
            <span class="apidocSignatureSpan">(a, b, problemPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.defineMethod">
            function <span class="apidocSignatureSpan">regenerator.types.</span>defineMethod
            <span class="apidocSignatureSpan">(name, func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.eachField">
            function <span class="apidocSignatureSpan">regenerator.types.</span>eachField
            <span class="apidocSignatureSpan">(object, callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.finalize">
            function <span class="apidocSignatureSpan">regenerator.types.</span>finalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.getFieldNames">
            function <span class="apidocSignatureSpan">regenerator.types.</span>getFieldNames
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.getFieldValue">
            function <span class="apidocSignatureSpan">regenerator.types.</span>getFieldValue
            <span class="apidocSignatureSpan">(object, fieldName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.getSupertypeNames">
            function <span class="apidocSignatureSpan">regenerator.types.</span>getSupertypeNames
            <span class="apidocSignatureSpan">(typeName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.someField">
            function <span class="apidocSignatureSpan">regenerator.types.</span>someField
            <span class="apidocSignatureSpan">(object, callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.use">
            function <span class="apidocSignatureSpan">regenerator.types.</span>use
            <span class="apidocSignatureSpan">(plugin)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.visit">
            function <span class="apidocSignatureSpan">regenerator.types.</span>visit
            <span class="apidocSignatureSpan">(node, methods)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regenerator.types.</span>builders</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regenerator.types.</span>builtInTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regenerator.types.</span>namedTypes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regenerator.types.NodePath">module regenerator.types.NodePath</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.NodePath.NodePath">
            function <span class="apidocSignatureSpan">regenerator.types.</span>NodePath
            <span class="apidocSignatureSpan">(value, parentPath, name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regenerator.types.NodePath.prototype">module regenerator.types.NodePath.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.NodePath.prototype._computeNode">
            function <span class="apidocSignatureSpan">regenerator.types.NodePath.prototype.</span>_computeNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.NodePath.prototype._computeParent">
            function <span class="apidocSignatureSpan">regenerator.types.NodePath.prototype.</span>_computeParent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.NodePath.prototype._computeScope">
            function <span class="apidocSignatureSpan">regenerator.types.NodePath.prototype.</span>_computeScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.NodePath.prototype.canBeFirstInStatement">
            function <span class="apidocSignatureSpan">regenerator.types.NodePath.prototype.</span>canBeFirstInStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.NodePath.prototype.firstInStatement">
            function <span class="apidocSignatureSpan">regenerator.types.NodePath.prototype.</span>firstInStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.NodePath.prototype.getValueProperty">
            function <span class="apidocSignatureSpan">regenerator.types.NodePath.prototype.</span>getValueProperty
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.NodePath.prototype.needsParens">
            function <span class="apidocSignatureSpan">regenerator.types.NodePath.prototype.</span>needsParens
            <span class="apidocSignatureSpan">(assumeExpressionContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.NodePath.prototype.prune">
            function <span class="apidocSignatureSpan">regenerator.types.NodePath.prototype.</span>prune
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.NodePath.prototype.replace">
            function <span class="apidocSignatureSpan">regenerator.types.NodePath.prototype.</span>replace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regenerator.types.Path">module regenerator.types.Path</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Path.Path">
            function <span class="apidocSignatureSpan">regenerator.types.</span>Path
            <span class="apidocSignatureSpan">(value, parentPath, name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regenerator.types.Path.prototype">module regenerator.types.Path.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Path.prototype.each">
            function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>each
            <span class="apidocSignatureSpan">(callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Path.prototype.filter">
            function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>filter
            <span class="apidocSignatureSpan">(callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Path.prototype.get">
            function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>get
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Path.prototype.getValueProperty">
            function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>getValueProperty
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Path.prototype.insertAfter">
            function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>insertAfter
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Path.prototype.insertAt">
            function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>insertAt
            <span class="apidocSignatureSpan">(index, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Path.prototype.insertBefore">
            function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>insertBefore
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Path.prototype.map">
            function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>map
            <span class="apidocSignatureSpan">(callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Path.prototype.pop">
            function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Path.prototype.push">
            function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>push
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Path.prototype.replace">
            function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>replace
            <span class="apidocSignatureSpan">(replacement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Path.prototype.shift">
            function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>shift
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Path.prototype.unshift">
            function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>unshift
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regenerator.types.PathVisitor">module regenerator.types.PathVisitor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.PathVisitor.PathVisitor">
            function <span class="apidocSignatureSpan">regenerator.types.</span>PathVisitor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.PathVisitor.fromMethodsObject">
            function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.</span>fromMethodsObject
            <span class="apidocSignatureSpan">(methods)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.PathVisitor.visit">
            function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.</span>visit
            <span class="apidocSignatureSpan">(node, methods)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regenerator.types.PathVisitor.prototype">module regenerator.types.PathVisitor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.PathVisitor.prototype.AbortRequest">
            function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.prototype.</span>AbortRequest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.PathVisitor.prototype.abort">
            function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.prototype.</span>abort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.PathVisitor.prototype.acquireContext">
            function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.prototype.</span>acquireContext
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.PathVisitor.prototype.releaseContext">
            function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.prototype.</span>releaseContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.PathVisitor.prototype.reportChanged">
            function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.prototype.</span>reportChanged
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.PathVisitor.prototype.reset">
            function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.prototype.</span>reset
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.PathVisitor.prototype.visit">
            function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.prototype.</span>visit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.PathVisitor.prototype.visitWithoutReset">
            function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.prototype.</span>visitWithoutReset
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.PathVisitor.prototype.wasChangeReported">
            function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.prototype.</span>wasChangeReported
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regenerator.types.Type">module regenerator.types.Type</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Type.Type">
            function <span class="apidocSignatureSpan">regenerator.types.</span>Type
            <span class="apidocSignatureSpan">(check, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Type.def">
            function <span class="apidocSignatureSpan">regenerator.types.Type.</span>def
            <span class="apidocSignatureSpan">(typeName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Type.fromArray">
            function <span class="apidocSignatureSpan">regenerator.types.Type.</span>fromArray
            <span class="apidocSignatureSpan">(arr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Type.fromObject">
            function <span class="apidocSignatureSpan">regenerator.types.Type.</span>fromObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Type.or">
            function <span class="apidocSignatureSpan">regenerator.types.Type.</span>or
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regenerator.types.Type.prototype">module regenerator.types.Type.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Type.prototype.arrayOf">
            function <span class="apidocSignatureSpan">regenerator.types.Type.prototype.</span>arrayOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Type.prototype.assert">
            function <span class="apidocSignatureSpan">regenerator.types.Type.prototype.</span>assert
            <span class="apidocSignatureSpan">(value, deep)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.Type.prototype.toString">
            function <span class="apidocSignatureSpan">regenerator.types.Type.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regenerator.types.astNodesAreEquivalent">module regenerator.types.astNodesAreEquivalent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.astNodesAreEquivalent.astNodesAreEquivalent">
            function <span class="apidocSignatureSpan">regenerator.types.</span>astNodesAreEquivalent
            <span class="apidocSignatureSpan">(a, b, problemPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.astNodesAreEquivalent.assert">
            function <span class="apidocSignatureSpan">regenerator.types.astNodesAreEquivalent.</span>assert
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regenerator.types.builders">module regenerator.types.builders</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.anyTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>anyTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.arrayExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>arrayExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.arrayPattern">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>arrayPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.arrayStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>arrayStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.arrayTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>arrayTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.arrowFunctionExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>arrowFunctionExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.arrowFunctionStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>arrowFunctionStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.assignmentExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>assignmentExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.assignmentPattern">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>assignmentPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.assignmentStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>assignmentStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.awaitExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>awaitExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.awaitStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>awaitStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.binaryExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>binaryExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.binaryStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>binaryStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.bindExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>bindExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.bindStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>bindStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.block">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>block
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.blockStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>blockStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.booleanLiteral">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>booleanLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.booleanLiteralStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>booleanLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.booleanLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>booleanLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.booleanTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>booleanTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.breakStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>breakStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.callExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>callExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.callStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>callStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.catchClause">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>catchClause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.classBody">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>classBody
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.classDeclaration">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>classDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.classExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>classExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.classImplements">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>classImplements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.classMethod">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>classMethod
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.classProperty">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>classProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.classPropertyDefinition">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>classPropertyDefinition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.classStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>classStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.commentBlock">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>commentBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.commentLine">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>commentLine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.comprehensionBlock">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>comprehensionBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.comprehensionExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>comprehensionExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.comprehensionStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>comprehensionStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.conditionalExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>conditionalExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.conditionalStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>conditionalStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.continueStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>continueStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.debuggerStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>debuggerStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.declareClass">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>declareClass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.declareExportAllDeclaration">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>declareExportAllDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.declareExportDeclaration">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>declareExportDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.declareFunction">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>declareFunction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.declareInterface">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>declareInterface
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.declareModule">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>declareModule
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.declareModuleExports">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>declareModuleExports
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.declareTypeAlias">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>declareTypeAlias
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.declareVariable">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>declareVariable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.decorator">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>decorator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.directive">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>directive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.directiveLiteral">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>directiveLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.directiveLiteralStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>directiveLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.doExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>doExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.doStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>doStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.doWhileStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>doWhileStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.emptyStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>emptyStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.emptyTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>emptyTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.existentialTypeParam">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>existentialTypeParam
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.existsTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>existsTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.exportAllDeclaration">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>exportAllDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.exportBatchSpecifier">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>exportBatchSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.exportDeclaration">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>exportDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.exportDefaultDeclaration">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>exportDefaultDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.exportDefaultSpecifier">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>exportDefaultSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.exportNamedDeclaration">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>exportNamedDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.exportNamespaceSpecifier">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>exportNamespaceSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.exportSpecifier">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>exportSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.expressionStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>expressionStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.file">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>file
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.forAwaitStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>forAwaitStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.forInStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>forInStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.forOfStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>forOfStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.forStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>forStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.functionDeclaration">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>functionDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.functionExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>functionExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.functionStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>functionStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.functionTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>functionTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.functionTypeParam">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>functionTypeParam
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.generatorExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>generatorExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.generatorStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>generatorStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.genericTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>genericTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.graphExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>graphExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.graphIndexExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>graphIndexExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.graphIndexStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>graphIndexStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.graphStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>graphStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.identifier">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>identifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.identifierStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>identifierStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.ifStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>ifStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.import">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>import
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.importDeclaration">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>importDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.importDefaultSpecifier">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>importDefaultSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.importNamespaceSpecifier">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>importNamespaceSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.importSpecifier">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>importSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.importStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>importStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.interfaceDeclaration">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>interfaceDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.interfaceExtends">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>interfaceExtends
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.intersectionTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>intersectionTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.jsxAttribute">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxAttribute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.jsxClosingElement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxClosingElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.jsxElement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.jsxElementStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxElementStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.jsxEmptyExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxEmptyExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.jsxEmptyStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxEmptyStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.jsxExpressionContainer">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxExpressionContainer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.jsxExpressionContainerStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxExpressionContainerStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.jsxIdentifier">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxIdentifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.jsxIdentifierStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxIdentifierStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.jsxMemberExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxMemberExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.jsxMemberStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxMemberStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.jsxNamespacedName">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxNamespacedName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.jsxOpeningElement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxOpeningElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.jsxSpreadAttribute">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxSpreadAttribute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.jsxText">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.jsxTextStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxTextStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.labeledStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>labeledStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.letExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>letExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.letStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>letStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.line">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.literal">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>literal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.literalStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>literalStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.logicalExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>logicalExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.logicalStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>logicalStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.memberExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>memberExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.memberStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>memberStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.memberTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>memberTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.metaProperty">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>metaProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.metaPropertyStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>metaPropertyStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.methodDefinition">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>methodDefinition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.mixedTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>mixedTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.newExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>newExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.newStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>newStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.noop">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>noop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.nullLiteral">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>nullLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.nullLiteralStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>nullLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.nullLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>nullLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.nullTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>nullTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.nullableTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>nullableTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.numberLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>numberLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.numberTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>numberTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.numericLiteral">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>numericLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.numericLiteralStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>numericLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.numericLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>numericLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.objectExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>objectExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.objectMethod">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>objectMethod
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.objectPattern">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>objectPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.objectProperty">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>objectProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.objectStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>objectStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.objectTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>objectTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.objectTypeCallProperty">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>objectTypeCallProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.objectTypeIndexer">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>objectTypeIndexer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.objectTypeProperty">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>objectTypeProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.parenthesizedExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>parenthesizedExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.parenthesizedStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>parenthesizedStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.position">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>position
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.program">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>program
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.property">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>property
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.propertyPattern">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>propertyPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.qualifiedTypeIdentifier">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>qualifiedTypeIdentifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.regExpLiteral">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>regExpLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.regExpLiteralStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>regExpLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.restElement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>restElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.restProperty">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>restProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.returnStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>returnStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.sequenceExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>sequenceExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.sequenceStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>sequenceStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.sourceLocation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>sourceLocation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.spreadElement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>spreadElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.spreadElementPattern">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>spreadElementPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.spreadProperty">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>spreadProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.spreadPropertyPattern">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>spreadPropertyPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.stringLiteral">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>stringLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.stringLiteralStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>stringLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.stringLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>stringLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.stringTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>stringTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.super">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.superStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>superStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.switchCase">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>switchCase
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.switchStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>switchStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.taggedTemplateExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>taggedTemplateExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.taggedTemplateStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>taggedTemplateStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.templateElement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>templateElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.templateLiteral">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>templateLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.templateLiteralStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>templateLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.thisExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>thisExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.thisStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>thisStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.thisTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>thisTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.throwStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>throwStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.tryStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>tryStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.tupleTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>tupleTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.typeAlias">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>typeAlias
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.typeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>typeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.typeCastExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>typeCastExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.typeCastStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>typeCastStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.typeParameter">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>typeParameter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.typeParameterDeclaration">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>typeParameterDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.typeParameterInstantiation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>typeParameterInstantiation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.typeofTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>typeofTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.unaryExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>unaryExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.unaryStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>unaryStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.unionTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>unionTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.updateExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>updateExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.updateStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>updateStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.variableDeclaration">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>variableDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.variableDeclarator">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>variableDeclarator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.voidTypeAnnotation">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>voidTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.whileStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>whileStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.withStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>withStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.yieldExpression">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>yieldExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.types.builders.yieldStatement">
            function <span class="apidocSignatureSpan">regenerator.types.builders.</span>yieldStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regenerator.util">module regenerator.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.util.defaults">
            function <span class="apidocSignatureSpan">regenerator.util.</span>defaults
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.util.isReference">
            function <span class="apidocSignatureSpan">regenerator.util.</span>isReference
            <span class="apidocSignatureSpan">(path, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.util.runtimeProperty">
            function <span class="apidocSignatureSpan">regenerator.util.</span>runtimeProperty
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regenerator.visit">module regenerator.visit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regenerator.visit.transform">
            function <span class="apidocSignatureSpan">regenerator.visit.</span>transform
            <span class="apidocSignatureSpan">(node, options)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regenerator" id="apidoc.module.regenerator">module regenerator</a></h1>


    <h2>
        <a href="#apidoc.element.regenerator.regenerator" id="apidoc.element.regenerator.regenerator">
        function <span class="apidocSignatureSpan"></span>regenerator
        <span class="apidocSignatureSpan">(file, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exports(file, options) {
  var data = [];
  return through(write, end);

  function write(buf) {
    data.push(buf);
  }

  function end() {
    try {
      this.queue(compile(data.join(""), options).code);
      this.queue(null);
    } catch (e) { this.emit('error', e); }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.compile" id="apidoc.element.regenerator.compile">
        function <span class="apidocSignatureSpan">regenerator.</span>compile
        <span class="apidocSignatureSpan">(source, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compile(source, options) {
  var result;

  options = utils.defaults(options || {}, {
    includeRuntime: false
  });

  // Shortcut: Transform only if generators or async functions present.
  if (genOrAsyncFunExp.test(source)) {
    result = require("babel-core").transform(source, transformOptions);
  } else {
    result = { code: source };
  }

  if (options.includeRuntime === true) {
    result.code = getRuntimeCode() + "\n" + result.code;
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
regenerator es6.js &gt; es5.js # Just the transform.
regenerator --include-runtime es6.js &gt; es5.js # Add the runtime too.
regenerator src lib # Transform every .js file in src and output to lib.
```

Programmatic usage:
```js
var es5Source = require("regenerator").<span class="apidocCodeKeywordSpan">compile</span>(es6Source).code;
var es5SourceWithRuntime = require("regenerator").compile(es6Source, {
  includeRuntime: true
}).code;
```

AST transformation:
```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.runtime" id="apidoc.element.regenerator.runtime">
        function <span class="apidocSignatureSpan">regenerator.</span>runtime
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function runtime() {
  regeneratorRuntime = require("regenerator-runtime");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// To get a writable stream for use as a browserify transform, call
// require("regenerator")().
module.exports = exports;

// To include the runtime globally in the current node process, call
// require("regenerator").<span class="apidocCodeKeywordSpan">runtime</span>().
function runtime() {
  regeneratorRuntime = require("regenerator-runtime");
}
exports.runtime = runtime;
runtime.path = require("regenerator-runtime/path.js").path;

var cachedRuntimeCode;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.transform" id="apidoc.element.regenerator.transform">
        function <span class="apidocSignatureSpan">regenerator.</span>transform
        <span class="apidocSignatureSpan">(node, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transform(node, options) {
  options = util.defaults(options || {}, {
    includeRuntime: false
  });

  var result = require("babel-core").transformFromAst(node, null, {
    presets: [require("regenerator-preset")],
    code: false,
    ast: true
  });

  node = result.ast;

  if (options.includeRuntime === true) {
    injectRuntime(n.File.check(node) ? node.program : node);
  }

  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).code;
```

AST transformation:
```js
var recast = require("recast");
var ast = recast.parse(es6Source);
ast = require("regenerator").<span class="apidocCodeKeywordSpan">transform</span>(ast);
var es5Source = recast.print(ast);
```

How can you get involved?
---

The easiest way to get involved is to look for buggy examples using [the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.NodePath" id="apidoc.element.regenerator.types.NodePath">
        function <span class="apidocSignatureSpan">regenerator.</span>types.NodePath
        <span class="apidocSignatureSpan">(value, parentPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodePath(value, parentPath, name) {
    if (!(this instanceof NodePath)) {
        throw new Error("NodePath constructor cannot be invoked without 'new'");
    }
    Path.call(this, value, parentPath, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Path" id="apidoc.element.regenerator.types.Path">
        function <span class="apidocSignatureSpan">regenerator.</span>types.Path
        <span class="apidocSignatureSpan">(value, parentPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Path(value, parentPath, name) {
    if (!(this instanceof Path)) {
        throw new Error("Path constructor cannot be invoked without 'new'");
    }

    if (parentPath) {
        if (!(parentPath instanceof Path)) {
            throw new Error("");
        }
    } else {
        parentPath = null;
        name = null;
    }

    // The value encapsulated by this Path, generally equal to
    // parentPath.value[name] if we have a parentPath.
    this.value = value;

    // The immediate parent Path of this Path.
    this.parentPath = parentPath;

    // The name of the property of parentPath.value through which this
    // Path's value was reached.
    this.name = name;

    // Calling path.get("child") multiple times always returns the same
    // child Path object, for both performance and consistency reasons.
    this.__childCache = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.PathVisitor" id="apidoc.element.regenerator.types.PathVisitor">
        function <span class="apidocSignatureSpan">regenerator.</span>types.PathVisitor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PathVisitor() {
    if (!(this instanceof PathVisitor)) {
        throw new Error(
          "PathVisitor constructor cannot be invoked without 'new'"
        );
    }

    // Permanent state.
    this._reusableContextStack = [];

    this._methodNameTable = computeMethodNameTable(this);
    this._shouldVisitComments =
      hasOwn.call(this._methodNameTable, "Block") ||
      hasOwn.call(this._methodNameTable, "Line");

    this.Context = makeContextConstructor(this);

    // State reset every time PathVisitor.prototype.visit is called.
    this._visiting = false;
    this._changeReported = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Type" id="apidoc.element.regenerator.types.Type">
        function <span class="apidocSignatureSpan">regenerator.</span>types.Type
        <span class="apidocSignatureSpan">(check, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Type(check, name) {
    var self = this;
    if (!(self instanceof Type)) {
        throw new Error("Type constructor cannot be invoked without 'new'");
    }

    // Unfortunately we can't elegantly reuse isFunction and isString,
    // here, because this code is executed while defining those types.
    if (objToStr.call(check) !== funObjStr) {
        throw new Error(check + " is not a function");
    }

    // The `name` parameter can be either a function or a string.
    var nameObjStr = objToStr.call(name);
    if (!(nameObjStr === funObjStr ||
      nameObjStr === strObjStr)) {
        throw new Error(name + " is neither a function nor a string");
    }

    Object.defineProperties(self, {
        name: {value: name},
        check: {
            value: function (value, deep) {
                var result = check.call(self, value, deep);
                if (!result &amp;&amp; deep &amp;&amp; objToStr.call(deep) === funObjStr)
                    deep(self, value);
                return result;
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.astNodesAreEquivalent" id="apidoc.element.regenerator.types.astNodesAreEquivalent">
        function <span class="apidocSignatureSpan">regenerator.</span>types.astNodesAreEquivalent
        <span class="apidocSignatureSpan">(a, b, problemPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function astNodesAreEquivalent(a, b, problemPath) {
    if (isArray.check(problemPath)) {
        problemPath.length = 0;
    } else {
        problemPath = null;
    }

    return areEquivalent(a, b, problemPath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regenerator.runtime" id="apidoc.module.regenerator.runtime">module regenerator.runtime</a></h1>


    <h2>
        <a href="#apidoc.element.regenerator.runtime.AsyncIterator" id="apidoc.element.regenerator.runtime.AsyncIterator">
        function <span class="apidocSignatureSpan">regenerator.runtime.</span>AsyncIterator
        <span class="apidocSignatureSpan">(generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncIterator(generator) {
  function invoke(method, arg, resolve, reject) {
    var record = tryCatch(generator[method], generator, arg);
    if (record.type === "throw") {
      reject(record.arg);
    } else {
      var result = record.arg;
      var value = result.value;
      if (value &amp;&amp;
          typeof value === "object" &amp;&amp;
          hasOwn.call(value, "__await")) {
        return Promise.resolve(value.__await).then(function(value) {
          invoke("next", value, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        });
      }

      return Promise.resolve(value).then(function(unwrapped) {
        // When a yielded Promise is resolved, its final value becomes
        // the .value of the Promise&lt;{value,done}&gt; result for the
        // current iteration. If the Promise is rejected, however, the
        // result for this iteration will be rejected with the same
        // reason. Note that rejections of yielded Promises are not
        // thrown back into the generator function, as is the case
        // when an awaited Promise is rejected. This difference in
        // behavior between yield and await is important, because it
        // allows the consumer to decide what to do with the yielded
        // rejection (swallow it and continue, manually .throw it back
        // into the generator, abandon iteration, whatever). With
        // await, by contrast, there is no opportunity to examine the
        // rejection reason outside the generator function, so the
        // only option is to throw it from the await expression, and
        // let the generator function handle the exception.
        result.value = unwrapped;
        resolve(result);
      }, reject);
    }
  }

  if (typeof process === "object" &amp;&amp; process.domain) {
    invoke = process.domain.bind(invoke);
  }

  var previousPromise;

  function enqueue(method, arg) {
    function callInvokeWithMethodAndArg() {
      return new Promise(function(resolve, reject) {
        invoke(method, arg, resolve, reject);
      });
    }

    return previousPromise =
      // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(
        callInvokeWithMethodAndArg,
        // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg
      ) : callInvokeWithMethodAndArg();
  }

  // Define the unified helper method that is used to implement .next,
  // .throw, and .return (see defineIteratorMethods).
  this._invoke = enqueue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.runtime.async" id="apidoc.element.regenerator.runtime.async">
        function <span class="apidocSignatureSpan">regenerator.runtime.</span>async
        <span class="apidocSignatureSpan">(innerFn, outerFn, self, tryLocsList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">async = function (innerFn, outerFn, self, tryLocsList) {
  var iter = new AsyncIterator(
    wrap(innerFn, outerFn, self, tryLocsList)
  );

  return runtime.isGeneratorFunction(outerFn)
    ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.runtime.awrap" id="apidoc.element.regenerator.runtime.awrap">
        function <span class="apidocSignatureSpan">regenerator.runtime.</span>awrap
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">awrap = function (arg) {
  return { __await: arg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.runtime.isGeneratorFunction" id="apidoc.element.regenerator.runtime.isGeneratorFunction">
        function <span class="apidocSignatureSpan">regenerator.runtime.</span>isGeneratorFunction
        <span class="apidocSignatureSpan">(genFun)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isGeneratorFunction = function (genFun) {
  var ctor = typeof genFun === "function" &amp;&amp; genFun.constructor;
  return ctor
    ? ctor === GeneratorFunction ||
      // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction"
    : false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.runtime.keys" id="apidoc.element.regenerator.runtime.keys">
        function <span class="apidocSignatureSpan">regenerator.runtime.</span>keys
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keys = function (object) {
  var keys = [];
  for (var key in object) {
    keys.push(key);
  }
  keys.reverse();

  // Rather than returning an object with a next method, we keep
  // things simple and return the next function itself.
  return function next() {
    while (keys.length) {
      var key = keys.pop();
      if (key in object) {
        next.value = key;
        next.done = false;
        return next;
      }
    }

    // To avoid creating an additional object, we just hang the .value
    // and .done properties off the next function object itself. This
    // also ensures that the minifier will not anonymize the function.
    next.done = true;
    return next;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.runtime.mark" id="apidoc.element.regenerator.runtime.mark">
        function <span class="apidocSignatureSpan">regenerator.runtime.</span>mark
        <span class="apidocSignatureSpan">(genFun)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mark = function (genFun) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
  } else {
    genFun.__proto__ = GeneratorFunctionPrototype;
    if (!(toStringTagSymbol in genFun)) {
      genFun[toStringTagSymbol] = "GeneratorFunction";
    }
  }
  genFun.prototype = Object.create(Gp);
  return genFun;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.runtime.values" id="apidoc.element.regenerator.runtime.values">
        function <span class="apidocSignatureSpan">regenerator.runtime.</span>values
        <span class="apidocSignatureSpan">(iterable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function values(iterable) {
  if (iterable) {
    var iteratorMethod = iterable[iteratorSymbol];
    if (iteratorMethod) {
      return iteratorMethod.call(iterable);
    }

    if (typeof iterable.next === "function") {
      return iterable;
    }

    if (!isNaN(iterable.length)) {
      var i = -1, next = function next() {
        while (++i &lt; iterable.length) {
          if (hasOwn.call(iterable, i)) {
            next.value = iterable[i];
            next.done = false;
            return next;
          }
        }

        next.value = undefined;
        next.done = true;

        return next;
      };

      return next.next = next;
    }
  }

  // Return an iterator with no values.
  return { next: doneResult };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.runtime.wrap" id="apidoc.element.regenerator.runtime.wrap">
        function <span class="apidocSignatureSpan">regenerator.runtime.</span>wrap
        <span class="apidocSignatureSpan">(innerFn, outerFn, self, tryLocsList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrap(innerFn, outerFn, self, tryLocsList) {
  // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
  var protoGenerator = outerFn &amp;&amp; outerFn.prototype instanceof Generator ? outerFn : Generator;
  var generator = Object.create(protoGenerator.prototype);
  var context = new Context(tryLocsList || []);

  // The ._invoke method unifies the implementations of the .next,
  // .throw, and .return methods.
  generator._invoke = makeInvokeMethod(innerFn, self, context);

  return generator;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regenerator.types" id="apidoc.module.regenerator.types">module regenerator.types</a></h1>


    <h2>
        <a href="#apidoc.element.regenerator.types.NodePath" id="apidoc.element.regenerator.types.NodePath">
        function <span class="apidocSignatureSpan">regenerator.types.</span>NodePath
        <span class="apidocSignatureSpan">(value, parentPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodePath(value, parentPath, name) {
    if (!(this instanceof NodePath)) {
        throw new Error("NodePath constructor cannot be invoked without 'new'");
    }
    Path.call(this, value, parentPath, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Path" id="apidoc.element.regenerator.types.Path">
        function <span class="apidocSignatureSpan">regenerator.types.</span>Path
        <span class="apidocSignatureSpan">(value, parentPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Path(value, parentPath, name) {
    if (!(this instanceof Path)) {
        throw new Error("Path constructor cannot be invoked without 'new'");
    }

    if (parentPath) {
        if (!(parentPath instanceof Path)) {
            throw new Error("");
        }
    } else {
        parentPath = null;
        name = null;
    }

    // The value encapsulated by this Path, generally equal to
    // parentPath.value[name] if we have a parentPath.
    this.value = value;

    // The immediate parent Path of this Path.
    this.parentPath = parentPath;

    // The name of the property of parentPath.value through which this
    // Path's value was reached.
    this.name = name;

    // Calling path.get("child") multiple times always returns the same
    // child Path object, for both performance and consistency reasons.
    this.__childCache = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.PathVisitor" id="apidoc.element.regenerator.types.PathVisitor">
        function <span class="apidocSignatureSpan">regenerator.types.</span>PathVisitor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PathVisitor() {
    if (!(this instanceof PathVisitor)) {
        throw new Error(
          "PathVisitor constructor cannot be invoked without 'new'"
        );
    }

    // Permanent state.
    this._reusableContextStack = [];

    this._methodNameTable = computeMethodNameTable(this);
    this._shouldVisitComments =
      hasOwn.call(this._methodNameTable, "Block") ||
      hasOwn.call(this._methodNameTable, "Line");

    this.Context = makeContextConstructor(this);

    // State reset every time PathVisitor.prototype.visit is called.
    this._visiting = false;
    this._changeReported = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Type" id="apidoc.element.regenerator.types.Type">
        function <span class="apidocSignatureSpan">regenerator.types.</span>Type
        <span class="apidocSignatureSpan">(check, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Type(check, name) {
    var self = this;
    if (!(self instanceof Type)) {
        throw new Error("Type constructor cannot be invoked without 'new'");
    }

    // Unfortunately we can't elegantly reuse isFunction and isString,
    // here, because this code is executed while defining those types.
    if (objToStr.call(check) !== funObjStr) {
        throw new Error(check + " is not a function");
    }

    // The `name` parameter can be either a function or a string.
    var nameObjStr = objToStr.call(name);
    if (!(nameObjStr === funObjStr ||
      nameObjStr === strObjStr)) {
        throw new Error(name + " is neither a function nor a string");
    }

    Object.defineProperties(self, {
        name: {value: name},
        check: {
            value: function (value, deep) {
                var result = check.call(self, value, deep);
                if (!result &amp;&amp; deep &amp;&amp; objToStr.call(deep) === funObjStr)
                    deep(self, value);
                return result;
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.astNodesAreEquivalent" id="apidoc.element.regenerator.types.astNodesAreEquivalent">
        function <span class="apidocSignatureSpan">regenerator.types.</span>astNodesAreEquivalent
        <span class="apidocSignatureSpan">(a, b, problemPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function astNodesAreEquivalent(a, b, problemPath) {
    if (isArray.check(problemPath)) {
        problemPath.length = 0;
    } else {
        problemPath = null;
    }

    return areEquivalent(a, b, problemPath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.defineMethod" id="apidoc.element.regenerator.types.defineMethod">
        function <span class="apidocSignatureSpan">regenerator.types.</span>defineMethod
        <span class="apidocSignatureSpan">(name, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineMethod = function (name, func) {
    var old = nodePrototype[name];

    // Pass undefined as func to delete nodePrototype[name].
    if (isUndefined.check(func)) {
        delete nodePrototype[name];

    } else {
        isFunction.assert(func);

        Object.defineProperty(nodePrototype, name, {
            enumerable: true, // For discoverability.
            configurable: true, // For delete proto[name].
            value: func
        });
    }

    return old;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.eachField" id="apidoc.element.regenerator.types.eachField">
        function <span class="apidocSignatureSpan">regenerator.types.</span>eachField
        <span class="apidocSignatureSpan">(object, callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachField = function (object, callback, context) {
    getFieldNames(object).forEach(function (name) {
        callback.call(this, name, getFieldValue(object, name));
    }, context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.finalize" id="apidoc.element.regenerator.types.finalize">
        function <span class="apidocSignatureSpan">regenerator.types.</span>finalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finalize = function () {
    Object.keys(defCache).forEach(function (name) {
        defCache[name].finalize();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.getFieldNames" id="apidoc.element.regenerator.types.getFieldNames">
        function <span class="apidocSignatureSpan">regenerator.types.</span>getFieldNames
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFieldNames(object) {
    var d = Def.fromValue(object);
    if (d) {
        return d.fieldNames.slice(0);
    }

    if ("type" in object) {
        throw new Error(
          "did not recognize object of type " +
          JSON.stringify(object.type)
        );
    }

    return Object.keys(object);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.getFieldValue" id="apidoc.element.regenerator.types.getFieldValue">
        function <span class="apidocSignatureSpan">regenerator.types.</span>getFieldValue
        <span class="apidocSignatureSpan">(object, fieldName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFieldValue(object, fieldName) {
    var d = Def.fromValue(object);
    if (d) {
        var field = d.allFields[fieldName];
        if (field) {
            return field.getValue(object);
        }
    }

    return object &amp;&amp; object[fieldName];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.getSupertypeNames" id="apidoc.element.regenerator.types.getSupertypeNames">
        function <span class="apidocSignatureSpan">regenerator.types.</span>getSupertypeNames
        <span class="apidocSignatureSpan">(typeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSupertypeNames = function (typeName) {
    if (!hasOwn.call(defCache, typeName)) {
        throw new Error("");
    }
    var d = defCache[typeName];
    if (d.finalized !== true) {
        throw new Error("");
    }
    return d.supertypeList.slice(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.someField" id="apidoc.element.regenerator.types.someField">
        function <span class="apidocSignatureSpan">regenerator.types.</span>someField
        <span class="apidocSignatureSpan">(object, callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">someField = function (object, callback, context) {
    return getFieldNames(object).some(function (name) {
        return callback.call(this, name, getFieldValue(object, name));
    }, context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.use" id="apidoc.element.regenerator.types.use">
        function <span class="apidocSignatureSpan">regenerator.types.</span>use
        <span class="apidocSignatureSpan">(plugin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function use(plugin) {
    var idx = used.indexOf(plugin);
    if (idx === -1) {
        idx = used.length;
        used.push(plugin);
        usedResult[idx] = plugin(fork);
    }
    return usedResult[idx];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.visit" id="apidoc.element.regenerator.types.visit">
        function <span class="apidocSignatureSpan">regenerator.types.</span>visit
        <span class="apidocSignatureSpan">(node, methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function visit(node, methods) {
    return PathVisitor.fromMethodsObject(methods).visit(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regenerator.types.NodePath" id="apidoc.module.regenerator.types.NodePath">module regenerator.types.NodePath</a></h1>


    <h2>
        <a href="#apidoc.element.regenerator.types.NodePath.NodePath" id="apidoc.element.regenerator.types.NodePath.NodePath">
        function <span class="apidocSignatureSpan">regenerator.types.</span>NodePath
        <span class="apidocSignatureSpan">(value, parentPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodePath(value, parentPath, name) {
    if (!(this instanceof NodePath)) {
        throw new Error("NodePath constructor cannot be invoked without 'new'");
    }
    Path.call(this, value, parentPath, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regenerator.types.NodePath.prototype" id="apidoc.module.regenerator.types.NodePath.prototype">module regenerator.types.NodePath.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.regenerator.types.NodePath.prototype._computeNode" id="apidoc.element.regenerator.types.NodePath.prototype._computeNode">
        function <span class="apidocSignatureSpan">regenerator.types.NodePath.prototype.</span>_computeNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_computeNode = function () {
    var value = this.value;
    if (n.Node.check(value)) {
        return value;
    }

    var pp = this.parentPath;
    return pp &amp;&amp; pp.node || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.NodePath.prototype._computeParent" id="apidoc.element.regenerator.types.NodePath.prototype._computeParent">
        function <span class="apidocSignatureSpan">regenerator.types.NodePath.prototype.</span>_computeParent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_computeParent = function () {
    var value = this.value;
    var pp = this.parentPath;

    if (!n.Node.check(value)) {
        while (pp &amp;&amp; !n.Node.check(pp.value)) {
            pp = pp.parentPath;
        }

        if (pp) {
            pp = pp.parentPath;
        }
    }

    while (pp &amp;&amp; !n.Node.check(pp.value)) {
        pp = pp.parentPath;
    }

    return pp || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.NodePath.prototype._computeScope" id="apidoc.element.regenerator.types.NodePath.prototype._computeScope">
        function <span class="apidocSignatureSpan">regenerator.types.NodePath.prototype.</span>_computeScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_computeScope = function () {
    var value = this.value;
    var pp = this.parentPath;
    var scope = pp &amp;&amp; pp.scope;

    if (n.Node.check(value) &amp;&amp;
      Scope.isEstablishedBy(value)) {
        scope = new Scope(this, scope);
    }

    return scope || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.NodePath.prototype.canBeFirstInStatement" id="apidoc.element.regenerator.types.NodePath.prototype.canBeFirstInStatement">
        function <span class="apidocSignatureSpan">regenerator.types.NodePath.prototype.</span>canBeFirstInStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canBeFirstInStatement = function () {
    var node = this.node;
    return !n.FunctionExpression.check(node)
      &amp;&amp; !n.ObjectExpression.check(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.NodePath.prototype.firstInStatement" id="apidoc.element.regenerator.types.NodePath.prototype.firstInStatement">
        function <span class="apidocSignatureSpan">regenerator.types.NodePath.prototype.</span>firstInStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">firstInStatement = function () {
    return firstInStatement(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.NodePath.prototype.getValueProperty" id="apidoc.element.regenerator.types.NodePath.prototype.getValueProperty">
        function <span class="apidocSignatureSpan">regenerator.types.NodePath.prototype.</span>getValueProperty
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getValueProperty = function (name) {
    return types.getFieldValue(this.value, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.NodePath.prototype.needsParens" id="apidoc.element.regenerator.types.NodePath.prototype.needsParens">
        function <span class="apidocSignatureSpan">regenerator.types.NodePath.prototype.</span>needsParens
        <span class="apidocSignatureSpan">(assumeExpressionContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">needsParens = function (assumeExpressionContext) {
    var pp = this.parentPath;
    if (!pp) {
        return false;
    }

    var node = this.value;

    // Only expressions need parentheses.
    if (!n.Expression.check(node)) {
        return false;
    }

    // Identifiers never need parentheses.
    if (node.type === "Identifier") {
        return false;
    }

    while (!n.Node.check(pp.value)) {
        pp = pp.parentPath;
        if (!pp) {
            return false;
        }
    }

    var parent = pp.value;

    switch (node.type) {
        case "UnaryExpression":
        case "SpreadElement":
        case "SpreadProperty":
            return parent.type === "MemberExpression"
              &amp;&amp; this.name === "object"
              &amp;&amp; parent.object === node;

        case "BinaryExpression":
        case "LogicalExpression":
            switch (parent.type) {
                case "CallExpression":
                    return this.name === "callee"
                      &amp;&amp; parent.callee === node;

                case "UnaryExpression":
                case "SpreadElement":
                case "SpreadProperty":
                    return true;

                case "MemberExpression":
                    return this.name === "object"
                      &amp;&amp; parent.object === node;

                case "BinaryExpression":
                case "LogicalExpression":
                    var po = parent.operator;
                    var pp = PRECEDENCE[po];
                    var no = node.operator;
                    var np = PRECEDENCE[no];

                    if (pp &gt; np) {
                        return true;
                    }

                    if (pp === np &amp;&amp; this.name === "right") {
                        if (parent.right !== node) {
                            throw new Error("Nodes must be equal");
                        }
                        return true;
                    }

                default:
                    return false;
            }

        case "SequenceExpression":
            switch (parent.type) {
                case "ForStatement":
                    // Although parentheses wouldn't hurt around sequence
                    // expressions in the head of for loops, traditional style
                    // dictates that e.g. i++, j++ should not be wrapped with
                    // parentheses.
                    return false;

                case "ExpressionStatement":
                    return this.name !== "expression";

                default:
                    // Otherwise err on the side of overparenthesization, adding
                    // explicit exceptions above if this proves overzealous.
                    return true;
            }

        case "YieldExpression":
            switch (parent.type) {
                case "BinaryExpression":
                case "LogicalExpression":
                case "UnaryExpression":
                case "SpreadElement":
                case "SpreadProperty":
                case "CallExpression":
                case "MemberExpression":
                case "NewExpression":
                case "ConditionalExpression":
                case "YieldExpression":
                    return true;

                default:
                    return false;
            }

        case "Literal":
            return parent.type === "MemberExpression"
              &amp;&amp; isNumber.check(node.value)
              &amp;&amp; this.name === "object"
              &amp;&amp; parent.object === node;

        case "AssignmentExpression":
        case "ConditionalExpression":
            switch (parent.type) {
                case "UnaryExpression":
                case "SpreadElement":
                case "SpreadProperty":
                case "BinaryExpression":
                case "LogicalExpression":
                    return true;

                case "CallExpression":
                    return this.name === "callee"
                      &amp;&amp; parent.callee === node;

                case "ConditionalExpression":
                    return this.name === " ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.NodePath.prototype.prune" id="apidoc.element.regenerator.types.NodePath.prototype.prune">
        function <span class="apidocSignatureSpan">regenerator.types.NodePath.prototype.</span>prune
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prune = function () {
    var remainingNodePath = this.parent;

    this.replace();

    return cleanUpNodesAfterPrune(remainingNodePath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.NodePath.prototype.replace" id="apidoc.element.regenerator.types.NodePath.prototype.replace">
        function <span class="apidocSignatureSpan">regenerator.types.NodePath.prototype.</span>replace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function () {
    delete this.node;
    delete this.parent;
    delete this.scope;
    return Path.prototype.replace.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regenerator.types.Path" id="apidoc.module.regenerator.types.Path">module regenerator.types.Path</a></h1>


    <h2>
        <a href="#apidoc.element.regenerator.types.Path.Path" id="apidoc.element.regenerator.types.Path.Path">
        function <span class="apidocSignatureSpan">regenerator.types.</span>Path
        <span class="apidocSignatureSpan">(value, parentPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Path(value, parentPath, name) {
    if (!(this instanceof Path)) {
        throw new Error("Path constructor cannot be invoked without 'new'");
    }

    if (parentPath) {
        if (!(parentPath instanceof Path)) {
            throw new Error("");
        }
    } else {
        parentPath = null;
        name = null;
    }

    // The value encapsulated by this Path, generally equal to
    // parentPath.value[name] if we have a parentPath.
    this.value = value;

    // The immediate parent Path of this Path.
    this.parentPath = parentPath;

    // The name of the property of parentPath.value through which this
    // Path's value was reached.
    this.name = name;

    // Calling path.get("child") multiple times always returns the same
    // child Path object, for both performance and consistency reasons.
    this.__childCache = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regenerator.types.Path.prototype" id="apidoc.module.regenerator.types.Path.prototype">module regenerator.types.Path.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.regenerator.types.Path.prototype.each" id="apidoc.element.regenerator.types.Path.prototype.each">
        function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>each
        <span class="apidocSignatureSpan">(callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function each(callback, context) {
    var childPaths = [];
    var len = this.value.length;
    var i = 0;

    // Collect all the original child paths before invoking the callback.
    for (var i = 0; i &lt; len; ++i) {
        if (hasOwn.call(this.value, i)) {
            childPaths[i] = this.get(i);
        }
    }

    // Invoke the callback on just the original child paths, regardless of
    // any modifications made to the array by the callback. I chose these
    // semantics over cleverly invoking the callback on new elements because
    // this way is much easier to reason about.
    context = context || this;
    for (i = 0; i &lt; len; ++i) {
        if (hasOwn.call(childPaths, i)) {
            callback.call(context, childPaths[i]);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Path.prototype.filter" id="apidoc.element.regenerator.types.Path.prototype.filter">
        function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>filter
        <span class="apidocSignatureSpan">(callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filter(callback, context) {
    var result = [];

    this.each(function (childPath) {
        if (callback.call(this, childPath)) {
            result.push(childPath);
        }
    }, context);

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Path.prototype.get" id="apidoc.element.regenerator.types.Path.prototype.get">
        function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>get
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function get(name) {
    var path = this;
    var names = arguments;
    var count = names.length;

    for (var i = 0; i &lt; count; ++i) {
        path = getChildPath(path, names[i]);
    }

    return path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Path.prototype.getValueProperty" id="apidoc.element.regenerator.types.Path.prototype.getValueProperty">
        function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>getValueProperty
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getValueProperty(name) {
    return this.value[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Path.prototype.insertAfter" id="apidoc.element.regenerator.types.Path.prototype.insertAfter">
        function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>insertAfter
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function insertAfter(node) {
    var pp = this.parentPath;
    var argc = arguments.length;
    var insertAtArgs = [this.name + 1];
    for (var i = 0; i &lt; argc; ++i) {
        insertAtArgs.push(arguments[i]);
    }
    return pp.insertAt.apply(pp, insertAtArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Path.prototype.insertAt" id="apidoc.element.regenerator.types.Path.prototype.insertAt">
        function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>insertAt
        <span class="apidocSignatureSpan">(index, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function insertAt(index, node) {
    var argc = arguments.length;
    var move = getMoves(this, argc - 1, index);
    if (move === emptyMoves) {
        return this;
    }

    index = Math.max(index, 0);

    for (var i = 1; i &lt; argc; ++i) {
        this.value[index + i - 1] = arguments[i];
    }

    move();

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Path.prototype.insertBefore" id="apidoc.element.regenerator.types.Path.prototype.insertBefore">
        function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>insertBefore
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function insertBefore(node) {
    var pp = this.parentPath;
    var argc = arguments.length;
    var insertAtArgs = [this.name];
    for (var i = 0; i &lt; argc; ++i) {
        insertAtArgs.push(arguments[i]);
    }
    return pp.insertAt.apply(pp, insertAtArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Path.prototype.map" id="apidoc.element.regenerator.types.Path.prototype.map">
        function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>map
        <span class="apidocSignatureSpan">(callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map(callback, context) {
    var result = [];

    this.each(function (childPath) {
        result.push(callback.call(this, childPath));
    }, context);

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Path.prototype.pop" id="apidoc.element.regenerator.types.Path.prototype.pop">
        function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pop() {
    isArray.assert(this.value);
    var cache = getChildCache(this);
    delete cache[this.value.length - 1];
    delete cache.length;
    return this.value.pop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Path.prototype.push" id="apidoc.element.regenerator.types.Path.prototype.push">
        function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>push
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function push(node) {
    isArray.assert(this.value);
    delete getChildCache(this).length
    return this.value.push.apply(this.value, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var genOrAsyncFunExp = /\bfunction\s*\*|\basync\b/;

function exports(file, options) {
var data = [];
return through(write, end);

function write(buf) {
  data.<span class="apidocCodeKeywordSpan">push</span>(buf);
}

function end() {
  try {
    this.queue(compile(data.join(""), options).code);
    this.queue(null);
  } catch (e) { this.emit('error', e); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Path.prototype.replace" id="apidoc.element.regenerator.types.Path.prototype.replace">
        function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>replace
        <span class="apidocSignatureSpan">(replacement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replace(replacement) {
    var results = [];
    var parentValue = this.parentPath.value;
    var parentCache = getChildCache(this.parentPath);
    var count = arguments.length;

    repairRelationshipWithParent(this);

    if (isArray.check(parentValue)) {
        var originalLength = parentValue.length;
        var move = getMoves(this.parentPath, count - 1, this.name + 1);

        var spliceArgs = [this.name, 1];
        for (var i = 0; i &lt; count; ++i) {
            spliceArgs.push(arguments[i]);
        }

        var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);

        if (splicedOut[0] !== this.value) {
            throw new Error("");
        }
        if (parentValue.length !== (originalLength - 1 + count)) {
            throw new Error("");
        }

        move();

        if (count === 0) {
            delete this.value;
            delete parentCache[this.name];
            this.__childCache = null;

        } else {
            if (parentValue[this.name] !== replacement) {
                throw new Error("");
            }

            if (this.value !== replacement) {
                this.value = replacement;
                this.__childCache = null;
            }

            for (i = 0; i &lt; count; ++i) {
                results.push(this.parentPath.get(this.name + i));
            }

            if (results[0] !== this) {
                throw new Error("");
            }
        }

    } else if (count === 1) {
        if (this.value !== replacement) {
            this.__childCache = null;
        }
        this.value = parentValue[this.name] = replacement;
        results.push(this);

    } else if (count === 0) {
        delete parentValue[this.name];
        delete this.value;
        this.__childCache = null;

        // Leave this path cached as parentCache[this.name], even though
        // it no longer has a value defined.

    } else {
        throw new Error("Could not replace path");
    }

    return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Path.prototype.shift" id="apidoc.element.regenerator.types.Path.prototype.shift">
        function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>shift
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shift() {
    var move = getMoves(this, -1);
    var result = this.value.shift();
    move();
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Path.prototype.unshift" id="apidoc.element.regenerator.types.Path.prototype.unshift">
        function <span class="apidocSignatureSpan">regenerator.types.Path.prototype.</span>unshift
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unshift(node) {
    var move = getMoves(this, arguments.length);
    var result = this.value.unshift.apply(this.value, arguments);
    move();
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regenerator.types.PathVisitor" id="apidoc.module.regenerator.types.PathVisitor">module regenerator.types.PathVisitor</a></h1>


    <h2>
        <a href="#apidoc.element.regenerator.types.PathVisitor.PathVisitor" id="apidoc.element.regenerator.types.PathVisitor.PathVisitor">
        function <span class="apidocSignatureSpan">regenerator.types.</span>PathVisitor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PathVisitor() {
    if (!(this instanceof PathVisitor)) {
        throw new Error(
          "PathVisitor constructor cannot be invoked without 'new'"
        );
    }

    // Permanent state.
    this._reusableContextStack = [];

    this._methodNameTable = computeMethodNameTable(this);
    this._shouldVisitComments =
      hasOwn.call(this._methodNameTable, "Block") ||
      hasOwn.call(this._methodNameTable, "Line");

    this.Context = makeContextConstructor(this);

    // State reset every time PathVisitor.prototype.visit is called.
    this._visiting = false;
    this._changeReported = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.PathVisitor.fromMethodsObject" id="apidoc.element.regenerator.types.PathVisitor.fromMethodsObject">
        function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.</span>fromMethodsObject
        <span class="apidocSignatureSpan">(methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromMethodsObject(methods) {
    if (methods instanceof PathVisitor) {
        return methods;
    }

    if (!isObject.check(methods)) {
        // An empty visitor?
        return new PathVisitor;
    }

    function Visitor() {
        if (!(this instanceof Visitor)) {
            throw new Error(
              "Visitor constructor cannot be invoked without 'new'"
            );
        }
        PathVisitor.call(this);
    }

    var Vp = Visitor.prototype = Object.create(PVp);
    Vp.constructor = Visitor;

    extend(Vp, methods);
    extend(Visitor, PathVisitor);

    isFunction.assert(Visitor.fromMethodsObject);
    isFunction.assert(Visitor.visit);

    return new Visitor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.PathVisitor.visit" id="apidoc.element.regenerator.types.PathVisitor.visit">
        function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.</span>visit
        <span class="apidocSignatureSpan">(node, methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function visit(node, methods) {
    return PathVisitor.fromMethodsObject(methods).visit(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regenerator.types.PathVisitor.prototype" id="apidoc.module.regenerator.types.PathVisitor.prototype">module regenerator.types.PathVisitor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.regenerator.types.PathVisitor.prototype.AbortRequest" id="apidoc.element.regenerator.types.PathVisitor.prototype.AbortRequest">
        function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.prototype.</span>AbortRequest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AbortRequest() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.PathVisitor.prototype.abort" id="apidoc.element.regenerator.types.PathVisitor.prototype.abort">
        function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.prototype.</span>abort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">abort = function () {
    var visitor = this;
    visitor._abortRequested = true;
    var request = new visitor.AbortRequest();

    // If you decide to catch this exception and stop it from propagating,
    // make sure to call its cancel method to avoid silencing other
    // exceptions that might be thrown later in the traversal.
    request.cancel = function () {
        visitor._abortRequested = false;
    };

    throw request;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.PathVisitor.prototype.acquireContext" id="apidoc.element.regenerator.types.PathVisitor.prototype.acquireContext">
        function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.prototype.</span>acquireContext
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acquireContext = function (path) {
    if (this._reusableContextStack.length === 0) {
        return new this.Context(path);
    }
    return this._reusableContextStack.pop().reset(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.PathVisitor.prototype.releaseContext" id="apidoc.element.regenerator.types.PathVisitor.prototype.releaseContext">
        function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.prototype.</span>releaseContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">releaseContext = function (context) {
    if (!(context instanceof this.Context)) {
        throw new Error("");
    }
    this._reusableContextStack.push(context);
    context.currentPath = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.PathVisitor.prototype.reportChanged" id="apidoc.element.regenerator.types.PathVisitor.prototype.reportChanged">
        function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.prototype.</span>reportChanged
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reportChanged = function () {
    this._changeReported = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.PathVisitor.prototype.reset" id="apidoc.element.regenerator.types.PathVisitor.prototype.reset">
        function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.prototype.</span>reset
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function (path) {
    // Empty stub; may be reassigned or overridden by subclasses.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.PathVisitor.prototype.visit" id="apidoc.element.regenerator.types.PathVisitor.prototype.visit">
        function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.prototype.</span>visit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visit = function () {
    if (this._visiting) {
        throw new Error(
          "Recursively calling visitor.visit(path) resets visitor state. " +
          "Try this.visit(path) or this.traverse(path) instead."
        );
    }

    // Private state that needs to be reset before every traversal.
    this._visiting = true;
    this._changeReported = false;
    this._abortRequested = false;

    var argc = arguments.length;
    var args = new Array(argc)
    for (var i = 0; i &lt; argc; ++i) {
        args[i] = arguments[i];
    }

    if (!(args[0] instanceof NodePath)) {
        args[0] = new NodePath({root: args[0]}).get("root");
    }

    // Called with the same arguments as .visit.
    this.reset.apply(this, args);

    try {
        var root = this.visitWithoutReset(args[0]);
        var didNotThrow = true;
    } finally {
        this._visiting = false;

        if (!didNotThrow &amp;&amp; this._abortRequested) {
            // If this.visitWithoutReset threw an exception and
            // this._abortRequested was set to true, return the root of
            // the AST instead of letting the exception propagate, so that
            // client code does not have to provide a try-catch block to
            // intercept the AbortRequest exception.  Other kinds of
            // exceptions will propagate without being intercepted and
            // rethrown by a catch block, so their stacks will accurately
            // reflect the original throwing context.
            return args[0].value;
        }
    }

    return root;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.PathVisitor.prototype.visitWithoutReset" id="apidoc.element.regenerator.types.PathVisitor.prototype.visitWithoutReset">
        function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.prototype.</span>visitWithoutReset
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitWithoutReset = function (path) {
    if (this instanceof this.Context) {
        // Since this.Context.prototype === this, there's a chance we
        // might accidentally call context.visitWithoutReset. If that
        // happens, re-invoke the method against context.visitor.
        return this.visitor.visitWithoutReset(path);
    }

    if (!(path instanceof NodePath)) {
        throw new Error("");
    }

    var value = path.value;

    var methodName = value &amp;&amp;
      typeof value === "object" &amp;&amp;
      typeof value.type === "string" &amp;&amp;
      this._methodNameTable[value.type];

    if (methodName) {
        var context = this.acquireContext(path);
        try {
            return context.invokeVisitorMethod(methodName);
        } finally {
            this.releaseContext(context);
        }

    } else {
        // If there was no visitor method to call, visit the children of
        // this node generically.
        return visitChildren(path, this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.PathVisitor.prototype.wasChangeReported" id="apidoc.element.regenerator.types.PathVisitor.prototype.wasChangeReported">
        function <span class="apidocSignatureSpan">regenerator.types.PathVisitor.prototype.</span>wasChangeReported
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wasChangeReported = function () {
    return this._changeReported;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regenerator.types.Type" id="apidoc.module.regenerator.types.Type">module regenerator.types.Type</a></h1>


    <h2>
        <a href="#apidoc.element.regenerator.types.Type.Type" id="apidoc.element.regenerator.types.Type.Type">
        function <span class="apidocSignatureSpan">regenerator.types.</span>Type
        <span class="apidocSignatureSpan">(check, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Type(check, name) {
    var self = this;
    if (!(self instanceof Type)) {
        throw new Error("Type constructor cannot be invoked without 'new'");
    }

    // Unfortunately we can't elegantly reuse isFunction and isString,
    // here, because this code is executed while defining those types.
    if (objToStr.call(check) !== funObjStr) {
        throw new Error(check + " is not a function");
    }

    // The `name` parameter can be either a function or a string.
    var nameObjStr = objToStr.call(name);
    if (!(nameObjStr === funObjStr ||
      nameObjStr === strObjStr)) {
        throw new Error(name + " is neither a function nor a string");
    }

    Object.defineProperties(self, {
        name: {value: name},
        check: {
            value: function (value, deep) {
                var result = check.call(self, value, deep);
                if (!result &amp;&amp; deep &amp;&amp; objToStr.call(deep) === funObjStr)
                    deep(self, value);
                return result;
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Type.def" id="apidoc.element.regenerator.types.Type.def">
        function <span class="apidocSignatureSpan">regenerator.types.Type.</span>def
        <span class="apidocSignatureSpan">(typeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">def = function (typeName) {
    isString.assert(typeName);
    return hasOwn.call(defCache, typeName)
      ? defCache[typeName]
      : defCache[typeName] = new Def(typeName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Type.fromArray" id="apidoc.element.regenerator.types.Type.fromArray">
        function <span class="apidocSignatureSpan">regenerator.types.Type.</span>fromArray
        <span class="apidocSignatureSpan">(arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromArray = function (arr) {
    if (!isArray.check(arr)) {
        throw new Error("");
    }
    if (arr.length !== 1) {
        throw new Error("only one element type is permitted for typed arrays");
    }
    return toType(arr[0]).arrayOf();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Type.fromObject" id="apidoc.element.regenerator.types.Type.fromObject">
        function <span class="apidocSignatureSpan">regenerator.types.Type.</span>fromObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromObject = function (obj) {
    var fields = Object.keys(obj).map(function (name) {
        return new Field(name, obj[name]);
    });

    return new Type(function (value, deep) {
        return isObject.check(value) &amp;&amp; fields.every(function (field) {
              return field.type.check(value[field.name], deep);
          });
    }, function () {
        return "{ " + fields.join(", ") + " }";
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Type.or" id="apidoc.element.regenerator.types.Type.or">
        function <span class="apidocSignatureSpan">regenerator.types.Type.</span>or
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">or = function () {
    var types = [];
    var len = arguments.length;
    for (var i = 0; i &lt; len; ++i)
        types.push(toType(arguments[i]));

    return new Type(function (value, deep) {
        for (var i = 0; i &lt; len; ++i)
            if (types[i].check(value, deep))
                return true;
        return false;
    }, function () {
        return types.join(" | ");
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regenerator.types.Type.prototype" id="apidoc.module.regenerator.types.Type.prototype">module regenerator.types.Type.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.regenerator.types.Type.prototype.arrayOf" id="apidoc.element.regenerator.types.Type.prototype.arrayOf">
        function <span class="apidocSignatureSpan">regenerator.types.Type.prototype.</span>arrayOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayOf = function () {
    var elemType = this;
    return new Type(function (value, deep) {
        return isArray.check(value) &amp;&amp; value.every(function (elem) {
              return elemType.check(elem, deep);
          });
    }, function () {
        return "[" + elemType + "]";
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Type.prototype.assert" id="apidoc.element.regenerator.types.Type.prototype.assert">
        function <span class="apidocSignatureSpan">regenerator.types.Type.prototype.</span>assert
        <span class="apidocSignatureSpan">(value, deep)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assert = function (value, deep) {
    if (!this.check(value, deep)) {
        var str = shallowStringify(value);
        throw new Error(str + " does not match type " + this);
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  injectRuntime(n.File.check(node) ? node.program : node);
}

return node;
};

function injectRuntime(program) {
n.Program.<span class="apidocCodeKeywordSpan">assert</span>(program);

// Include the runtime by modifying the AST rather than by concatenating
// strings. This technique will allow for more accurate source mapping.
var runtimePath = require("..").runtime.path;
var runtime = fs.readFileSync(runtimePath, "utf8");
var runtimeBody = recast.parse(runtime, {
  sourceFileName: runtimePath
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.Type.prototype.toString" id="apidoc.element.regenerator.types.Type.prototype.toString">
        function <span class="apidocSignatureSpan">regenerator.types.Type.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    var name = this.name;

    if (isString.check(name))
        return name;

    if (isFunction.check(name))
        return name.call(this) + "";

    return name + " type";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regenerator.types.astNodesAreEquivalent" id="apidoc.module.regenerator.types.astNodesAreEquivalent">module regenerator.types.astNodesAreEquivalent</a></h1>


    <h2>
        <a href="#apidoc.element.regenerator.types.astNodesAreEquivalent.astNodesAreEquivalent" id="apidoc.element.regenerator.types.astNodesAreEquivalent.astNodesAreEquivalent">
        function <span class="apidocSignatureSpan">regenerator.types.</span>astNodesAreEquivalent
        <span class="apidocSignatureSpan">(a, b, problemPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function astNodesAreEquivalent(a, b, problemPath) {
    if (isArray.check(problemPath)) {
        problemPath.length = 0;
    } else {
        problemPath = null;
    }

    return areEquivalent(a, b, problemPath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.astNodesAreEquivalent.assert" id="apidoc.element.regenerator.types.astNodesAreEquivalent.assert">
        function <span class="apidocSignatureSpan">regenerator.types.astNodesAreEquivalent.</span>assert
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assert = function (a, b) {
    var problemPath = [];
    if (!astNodesAreEquivalent(a, b, problemPath)) {
        if (problemPath.length === 0) {
            if (a !== b) {
                throw new Error("Nodes must be equal");
            }
        } else {
            throw new Error(
              "Nodes differ in the following path: " +
              problemPath.map(subscriptForProperty).join("")
            );
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  injectRuntime(n.File.check(node) ? node.program : node);
}

return node;
};

function injectRuntime(program) {
n.Program.<span class="apidocCodeKeywordSpan">assert</span>(program);

// Include the runtime by modifying the AST rather than by concatenating
// strings. This technique will allow for more accurate source mapping.
var runtimePath = require("..").runtime.path;
var runtime = fs.readFileSync(runtimePath, "utf8");
var runtimeBody = recast.parse(runtime, {
  sourceFileName: runtimePath
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regenerator.types.builders" id="apidoc.module.regenerator.types.builders">module regenerator.types.builders</a></h1>


    <h2>
        <a href="#apidoc.element.regenerator.types.builders.anyTypeAnnotation" id="apidoc.element.regenerator.types.builders.anyTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>anyTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anyTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.arrayExpression" id="apidoc.element.regenerator.types.builders.arrayExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>arrayExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.arrayPattern" id="apidoc.element.regenerator.types.builders.arrayPattern">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>arrayPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.arrayStatement" id="apidoc.element.regenerator.types.builders.arrayStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>arrayStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.arrayTypeAnnotation" id="apidoc.element.regenerator.types.builders.arrayTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>arrayTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.arrowFunctionExpression" id="apidoc.element.regenerator.types.builders.arrowFunctionExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>arrowFunctionExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrowFunctionExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.arrowFunctionStatement" id="apidoc.element.regenerator.types.builders.arrowFunctionStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>arrowFunctionStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrowFunctionStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.assignmentExpression" id="apidoc.element.regenerator.types.builders.assignmentExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>assignmentExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assignmentExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.assignmentPattern" id="apidoc.element.regenerator.types.builders.assignmentPattern">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>assignmentPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assignmentPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.assignmentStatement" id="apidoc.element.regenerator.types.builders.assignmentStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>assignmentStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assignmentStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.awaitExpression" id="apidoc.element.regenerator.types.builders.awaitExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>awaitExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">awaitExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.awaitStatement" id="apidoc.element.regenerator.types.builders.awaitStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>awaitStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">awaitStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.binaryExpression" id="apidoc.element.regenerator.types.builders.binaryExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>binaryExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">binaryExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.binaryStatement" id="apidoc.element.regenerator.types.builders.binaryStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>binaryStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">binaryStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.bindExpression" id="apidoc.element.regenerator.types.builders.bindExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>bindExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.bindStatement" id="apidoc.element.regenerator.types.builders.bindStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>bindStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.block" id="apidoc.element.regenerator.types.builders.block">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>block
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.blockStatement" id="apidoc.element.regenerator.types.builders.blockStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>blockStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">blockStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.booleanLiteral" id="apidoc.element.regenerator.types.builders.booleanLiteral">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>booleanLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">booleanLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.booleanLiteralStatement" id="apidoc.element.regenerator.types.builders.booleanLiteralStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>booleanLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">booleanLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.booleanLiteralTypeAnnotation" id="apidoc.element.regenerator.types.builders.booleanLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>booleanLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">booleanLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.booleanTypeAnnotation" id="apidoc.element.regenerator.types.builders.booleanTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>booleanTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">booleanTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.breakStatement" id="apidoc.element.regenerator.types.builders.breakStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>breakStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">breakStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.callExpression" id="apidoc.element.regenerator.types.builders.callExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>callExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.callStatement" id="apidoc.element.regenerator.types.builders.callStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>callStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.catchClause" id="apidoc.element.regenerator.types.builders.catchClause">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>catchClause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catchClause = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.classBody" id="apidoc.element.regenerator.types.builders.classBody">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>classBody
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classBody = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.classDeclaration" id="apidoc.element.regenerator.types.builders.classDeclaration">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>classDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.classExpression" id="apidoc.element.regenerator.types.builders.classExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>classExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.classImplements" id="apidoc.element.regenerator.types.builders.classImplements">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>classImplements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classImplements = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.classMethod" id="apidoc.element.regenerator.types.builders.classMethod">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>classMethod
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classMethod = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.classProperty" id="apidoc.element.regenerator.types.builders.classProperty">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>classProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.classPropertyDefinition" id="apidoc.element.regenerator.types.builders.classPropertyDefinition">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>classPropertyDefinition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classPropertyDefinition = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.classStatement" id="apidoc.element.regenerator.types.builders.classStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>classStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.commentBlock" id="apidoc.element.regenerator.types.builders.commentBlock">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>commentBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commentBlock = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.commentLine" id="apidoc.element.regenerator.types.builders.commentLine">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>commentLine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commentLine = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.comprehensionBlock" id="apidoc.element.regenerator.types.builders.comprehensionBlock">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>comprehensionBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comprehensionBlock = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.comprehensionExpression" id="apidoc.element.regenerator.types.builders.comprehensionExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>comprehensionExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comprehensionExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.comprehensionStatement" id="apidoc.element.regenerator.types.builders.comprehensionStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>comprehensionStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comprehensionStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.conditionalExpression" id="apidoc.element.regenerator.types.builders.conditionalExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>conditionalExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">conditionalExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.conditionalStatement" id="apidoc.element.regenerator.types.builders.conditionalStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>conditionalStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">conditionalStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.continueStatement" id="apidoc.element.regenerator.types.builders.continueStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>continueStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.debuggerStatement" id="apidoc.element.regenerator.types.builders.debuggerStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>debuggerStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">debuggerStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.declareClass" id="apidoc.element.regenerator.types.builders.declareClass">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>declareClass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareClass = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.declareExportAllDeclaration" id="apidoc.element.regenerator.types.builders.declareExportAllDeclaration">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>declareExportAllDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareExportAllDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.declareExportDeclaration" id="apidoc.element.regenerator.types.builders.declareExportDeclaration">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>declareExportDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareExportDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.declareFunction" id="apidoc.element.regenerator.types.builders.declareFunction">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>declareFunction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareFunction = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.declareInterface" id="apidoc.element.regenerator.types.builders.declareInterface">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>declareInterface
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareInterface = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.declareModule" id="apidoc.element.regenerator.types.builders.declareModule">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>declareModule
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareModule = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.declareModuleExports" id="apidoc.element.regenerator.types.builders.declareModuleExports">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>declareModuleExports
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareModuleExports = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.declareTypeAlias" id="apidoc.element.regenerator.types.builders.declareTypeAlias">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>declareTypeAlias
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareTypeAlias = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.declareVariable" id="apidoc.element.regenerator.types.builders.declareVariable">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>declareVariable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareVariable = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.decorator" id="apidoc.element.regenerator.types.builders.decorator">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>decorator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorator = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.directive" id="apidoc.element.regenerator.types.builders.directive">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>directive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directive = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.directiveLiteral" id="apidoc.element.regenerator.types.builders.directiveLiteral">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>directiveLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directiveLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.directiveLiteralStatement" id="apidoc.element.regenerator.types.builders.directiveLiteralStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>directiveLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directiveLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.doExpression" id="apidoc.element.regenerator.types.builders.doExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>doExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.doStatement" id="apidoc.element.regenerator.types.builders.doStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>doStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.doWhileStatement" id="apidoc.element.regenerator.types.builders.doWhileStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>doWhileStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doWhileStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.emptyStatement" id="apidoc.element.regenerator.types.builders.emptyStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>emptyStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emptyStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.emptyTypeAnnotation" id="apidoc.element.regenerator.types.builders.emptyTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>emptyTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emptyTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.existentialTypeParam" id="apidoc.element.regenerator.types.builders.existentialTypeParam">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>existentialTypeParam
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">existentialTypeParam = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.existsTypeAnnotation" id="apidoc.element.regenerator.types.builders.existsTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>existsTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">existsTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.exportAllDeclaration" id="apidoc.element.regenerator.types.builders.exportAllDeclaration">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>exportAllDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportAllDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.exportBatchSpecifier" id="apidoc.element.regenerator.types.builders.exportBatchSpecifier">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>exportBatchSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportBatchSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.exportDeclaration" id="apidoc.element.regenerator.types.builders.exportDeclaration">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>exportDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.exportDefaultDeclaration" id="apidoc.element.regenerator.types.builders.exportDefaultDeclaration">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>exportDefaultDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportDefaultDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.exportDefaultSpecifier" id="apidoc.element.regenerator.types.builders.exportDefaultSpecifier">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>exportDefaultSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportDefaultSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.exportNamedDeclaration" id="apidoc.element.regenerator.types.builders.exportNamedDeclaration">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>exportNamedDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportNamedDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.exportNamespaceSpecifier" id="apidoc.element.regenerator.types.builders.exportNamespaceSpecifier">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>exportNamespaceSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportNamespaceSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.exportSpecifier" id="apidoc.element.regenerator.types.builders.exportSpecifier">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>exportSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.expressionStatement" id="apidoc.element.regenerator.types.builders.expressionStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>expressionStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expressionStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.file" id="apidoc.element.regenerator.types.builders.file">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>file
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.forAwaitStatement" id="apidoc.element.regenerator.types.builders.forAwaitStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>forAwaitStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forAwaitStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.forInStatement" id="apidoc.element.regenerator.types.builders.forInStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>forInStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forInStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.forOfStatement" id="apidoc.element.regenerator.types.builders.forOfStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>forOfStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forOfStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.forStatement" id="apidoc.element.regenerator.types.builders.forStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>forStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.functionDeclaration" id="apidoc.element.regenerator.types.builders.functionDeclaration">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>functionDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.functionExpression" id="apidoc.element.regenerator.types.builders.functionExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>functionExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.functionStatement" id="apidoc.element.regenerator.types.builders.functionStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>functionStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.functionTypeAnnotation" id="apidoc.element.regenerator.types.builders.functionTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>functionTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.functionTypeParam" id="apidoc.element.regenerator.types.builders.functionTypeParam">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>functionTypeParam
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionTypeParam = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.generatorExpression" id="apidoc.element.regenerator.types.builders.generatorExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>generatorExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generatorExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.generatorStatement" id="apidoc.element.regenerator.types.builders.generatorStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>generatorStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generatorStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.genericTypeAnnotation" id="apidoc.element.regenerator.types.builders.genericTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>genericTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">genericTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.graphExpression" id="apidoc.element.regenerator.types.builders.graphExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>graphExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">graphExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.graphIndexExpression" id="apidoc.element.regenerator.types.builders.graphIndexExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>graphIndexExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">graphIndexExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.graphIndexStatement" id="apidoc.element.regenerator.types.builders.graphIndexStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>graphIndexStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">graphIndexStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.graphStatement" id="apidoc.element.regenerator.types.builders.graphStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>graphStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">graphStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.identifier" id="apidoc.element.regenerator.types.builders.identifier">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>identifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  return obj;
};

exports.runtimeProperty = function(name) {
  return b.memberExpression(
    b.<span class="apidocCodeKeywordSpan">identifier</span>("regeneratorRuntime"),
    b.identifier(name),
    false
  );
};

// Inspired by the isReference function from ast-util:
// https://github.com/eventualbuddha/ast-util/blob/9bf91c5ce8/lib/index.js#L466-L506
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.identifierStatement" id="apidoc.element.regenerator.types.builders.identifierStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>identifierStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identifierStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.ifStatement" id="apidoc.element.regenerator.types.builders.ifStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>ifStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ifStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.import" id="apidoc.element.regenerator.types.builders.import">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>import
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.importDeclaration" id="apidoc.element.regenerator.types.builders.importDeclaration">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>importDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.importDefaultSpecifier" id="apidoc.element.regenerator.types.builders.importDefaultSpecifier">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>importDefaultSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importDefaultSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.importNamespaceSpecifier" id="apidoc.element.regenerator.types.builders.importNamespaceSpecifier">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>importNamespaceSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importNamespaceSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.importSpecifier" id="apidoc.element.regenerator.types.builders.importSpecifier">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>importSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.importStatement" id="apidoc.element.regenerator.types.builders.importStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>importStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.interfaceDeclaration" id="apidoc.element.regenerator.types.builders.interfaceDeclaration">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>interfaceDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interfaceDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.interfaceExtends" id="apidoc.element.regenerator.types.builders.interfaceExtends">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>interfaceExtends
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interfaceExtends = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.intersectionTypeAnnotation" id="apidoc.element.regenerator.types.builders.intersectionTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>intersectionTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">intersectionTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.jsxAttribute" id="apidoc.element.regenerator.types.builders.jsxAttribute">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxAttribute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxAttribute = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.jsxClosingElement" id="apidoc.element.regenerator.types.builders.jsxClosingElement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxClosingElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxClosingElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.jsxElement" id="apidoc.element.regenerator.types.builders.jsxElement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.jsxElementStatement" id="apidoc.element.regenerator.types.builders.jsxElementStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxElementStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxElementStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.jsxEmptyExpression" id="apidoc.element.regenerator.types.builders.jsxEmptyExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxEmptyExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxEmptyExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.jsxEmptyStatement" id="apidoc.element.regenerator.types.builders.jsxEmptyStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxEmptyStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxEmptyStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.jsxExpressionContainer" id="apidoc.element.regenerator.types.builders.jsxExpressionContainer">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxExpressionContainer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxExpressionContainer = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.jsxExpressionContainerStatement" id="apidoc.element.regenerator.types.builders.jsxExpressionContainerStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxExpressionContainerStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxExpressionContainerStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.jsxIdentifier" id="apidoc.element.regenerator.types.builders.jsxIdentifier">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxIdentifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxIdentifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.jsxIdentifierStatement" id="apidoc.element.regenerator.types.builders.jsxIdentifierStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxIdentifierStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxIdentifierStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.jsxMemberExpression" id="apidoc.element.regenerator.types.builders.jsxMemberExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxMemberExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxMemberExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.jsxMemberStatement" id="apidoc.element.regenerator.types.builders.jsxMemberStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxMemberStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxMemberStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.jsxNamespacedName" id="apidoc.element.regenerator.types.builders.jsxNamespacedName">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxNamespacedName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxNamespacedName = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.jsxOpeningElement" id="apidoc.element.regenerator.types.builders.jsxOpeningElement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxOpeningElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxOpeningElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.jsxSpreadAttribute" id="apidoc.element.regenerator.types.builders.jsxSpreadAttribute">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxSpreadAttribute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxSpreadAttribute = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.jsxText" id="apidoc.element.regenerator.types.builders.jsxText">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxText = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.jsxTextStatement" id="apidoc.element.regenerator.types.builders.jsxTextStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>jsxTextStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxTextStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.labeledStatement" id="apidoc.element.regenerator.types.builders.labeledStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>labeledStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">labeledStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.letExpression" id="apidoc.element.regenerator.types.builders.letExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>letExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">letExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.letStatement" id="apidoc.element.regenerator.types.builders.letStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>letStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">letStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.line" id="apidoc.element.regenerator.types.builders.line">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">line = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.literal" id="apidoc.element.regenerator.types.builders.literal">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>literal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">literal = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.literalStatement" id="apidoc.element.regenerator.types.builders.literalStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>literalStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">literalStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.logicalExpression" id="apidoc.element.regenerator.types.builders.logicalExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>logicalExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logicalExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.logicalStatement" id="apidoc.element.regenerator.types.builders.logicalStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>logicalStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logicalStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.memberExpression" id="apidoc.element.regenerator.types.builders.memberExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>memberExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memberExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }

  return obj;
};

exports.runtimeProperty = function(name) {
  return b.<span class="apidocCodeKeywordSpan">memberExpression</span>(
    b.identifier("regeneratorRuntime"),
    b.identifier(name),
    false
  );
};

// Inspired by the isReference function from ast-util:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.memberStatement" id="apidoc.element.regenerator.types.builders.memberStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>memberStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memberStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.memberTypeAnnotation" id="apidoc.element.regenerator.types.builders.memberTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>memberTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memberTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.metaProperty" id="apidoc.element.regenerator.types.builders.metaProperty">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>metaProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">metaProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.metaPropertyStatement" id="apidoc.element.regenerator.types.builders.metaPropertyStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>metaPropertyStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">metaPropertyStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.methodDefinition" id="apidoc.element.regenerator.types.builders.methodDefinition">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>methodDefinition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">methodDefinition = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.mixedTypeAnnotation" id="apidoc.element.regenerator.types.builders.mixedTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>mixedTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixedTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.newExpression" id="apidoc.element.regenerator.types.builders.newExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>newExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.newStatement" id="apidoc.element.regenerator.types.builders.newStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>newStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.noop" id="apidoc.element.regenerator.types.builders.noop">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>noop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noop = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.nullLiteral" id="apidoc.element.regenerator.types.builders.nullLiteral">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>nullLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.nullLiteralStatement" id="apidoc.element.regenerator.types.builders.nullLiteralStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>nullLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.nullLiteralTypeAnnotation" id="apidoc.element.regenerator.types.builders.nullLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>nullLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.nullTypeAnnotation" id="apidoc.element.regenerator.types.builders.nullTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>nullTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.nullableTypeAnnotation" id="apidoc.element.regenerator.types.builders.nullableTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>nullableTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullableTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.numberLiteralTypeAnnotation" id="apidoc.element.regenerator.types.builders.numberLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>numberLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numberLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.numberTypeAnnotation" id="apidoc.element.regenerator.types.builders.numberTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>numberTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numberTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.numericLiteral" id="apidoc.element.regenerator.types.builders.numericLiteral">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>numericLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numericLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.numericLiteralStatement" id="apidoc.element.regenerator.types.builders.numericLiteralStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>numericLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numericLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.numericLiteralTypeAnnotation" id="apidoc.element.regenerator.types.builders.numericLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>numericLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numericLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.objectExpression" id="apidoc.element.regenerator.types.builders.objectExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>objectExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.objectMethod" id="apidoc.element.regenerator.types.builders.objectMethod">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>objectMethod
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectMethod = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.objectPattern" id="apidoc.element.regenerator.types.builders.objectPattern">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>objectPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.objectProperty" id="apidoc.element.regenerator.types.builders.objectProperty">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>objectProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.objectStatement" id="apidoc.element.regenerator.types.builders.objectStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>objectStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.objectTypeAnnotation" id="apidoc.element.regenerator.types.builders.objectTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>objectTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.objectTypeCallProperty" id="apidoc.element.regenerator.types.builders.objectTypeCallProperty">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>objectTypeCallProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectTypeCallProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.objectTypeIndexer" id="apidoc.element.regenerator.types.builders.objectTypeIndexer">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>objectTypeIndexer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectTypeIndexer = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.objectTypeProperty" id="apidoc.element.regenerator.types.builders.objectTypeProperty">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>objectTypeProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectTypeProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.parenthesizedExpression" id="apidoc.element.regenerator.types.builders.parenthesizedExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>parenthesizedExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parenthesizedExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.parenthesizedStatement" id="apidoc.element.regenerator.types.builders.parenthesizedStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>parenthesizedStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parenthesizedStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.position" id="apidoc.element.regenerator.types.builders.position">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>position
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">position = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.program" id="apidoc.element.regenerator.types.builders.program">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>program
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">program = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.property" id="apidoc.element.regenerator.types.builders.property">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>property
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">property = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.propertyPattern" id="apidoc.element.regenerator.types.builders.propertyPattern">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>propertyPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">propertyPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.qualifiedTypeIdentifier" id="apidoc.element.regenerator.types.builders.qualifiedTypeIdentifier">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>qualifiedTypeIdentifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">qualifiedTypeIdentifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.regExpLiteral" id="apidoc.element.regenerator.types.builders.regExpLiteral">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>regExpLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">regExpLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.regExpLiteralStatement" id="apidoc.element.regenerator.types.builders.regExpLiteralStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>regExpLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">regExpLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.restElement" id="apidoc.element.regenerator.types.builders.restElement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>restElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.restProperty" id="apidoc.element.regenerator.types.builders.restProperty">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>restProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.returnStatement" id="apidoc.element.regenerator.types.builders.returnStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>returnStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">returnStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.sequenceExpression" id="apidoc.element.regenerator.types.builders.sequenceExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>sequenceExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sequenceExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.sequenceStatement" id="apidoc.element.regenerator.types.builders.sequenceStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>sequenceStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sequenceStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.sourceLocation" id="apidoc.element.regenerator.types.builders.sourceLocation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>sourceLocation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sourceLocation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.spreadElement" id="apidoc.element.regenerator.types.builders.spreadElement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>spreadElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.spreadElementPattern" id="apidoc.element.regenerator.types.builders.spreadElementPattern">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>spreadElementPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadElementPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.spreadProperty" id="apidoc.element.regenerator.types.builders.spreadProperty">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>spreadProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.spreadPropertyPattern" id="apidoc.element.regenerator.types.builders.spreadPropertyPattern">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>spreadPropertyPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadPropertyPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.stringLiteral" id="apidoc.element.regenerator.types.builders.stringLiteral">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>stringLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.stringLiteralStatement" id="apidoc.element.regenerator.types.builders.stringLiteralStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>stringLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.stringLiteralTypeAnnotation" id="apidoc.element.regenerator.types.builders.stringLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>stringLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.stringTypeAnnotation" id="apidoc.element.regenerator.types.builders.stringTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>stringTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.super" id="apidoc.element.regenerator.types.builders.super">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.superStatement" id="apidoc.element.regenerator.types.builders.superStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>superStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.switchCase" id="apidoc.element.regenerator.types.builders.switchCase">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>switchCase
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchCase = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.switchStatement" id="apidoc.element.regenerator.types.builders.switchStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>switchStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.taggedTemplateExpression" id="apidoc.element.regenerator.types.builders.taggedTemplateExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>taggedTemplateExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">taggedTemplateExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.taggedTemplateStatement" id="apidoc.element.regenerator.types.builders.taggedTemplateStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>taggedTemplateStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">taggedTemplateStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.templateElement" id="apidoc.element.regenerator.types.builders.templateElement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>templateElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.templateLiteral" id="apidoc.element.regenerator.types.builders.templateLiteral">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>templateLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.templateLiteralStatement" id="apidoc.element.regenerator.types.builders.templateLiteralStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>templateLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.thisExpression" id="apidoc.element.regenerator.types.builders.thisExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>thisExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thisExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.thisStatement" id="apidoc.element.regenerator.types.builders.thisStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>thisStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thisStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.thisTypeAnnotation" id="apidoc.element.regenerator.types.builders.thisTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>thisTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thisTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.throwStatement" id="apidoc.element.regenerator.types.builders.throwStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>throwStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.tryStatement" id="apidoc.element.regenerator.types.builders.tryStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>tryStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.tupleTypeAnnotation" id="apidoc.element.regenerator.types.builders.tupleTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>tupleTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tupleTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.typeAlias" id="apidoc.element.regenerator.types.builders.typeAlias">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>typeAlias
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeAlias = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.typeAnnotation" id="apidoc.element.regenerator.types.builders.typeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>typeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.typeCastExpression" id="apidoc.element.regenerator.types.builders.typeCastExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>typeCastExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeCastExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.typeCastStatement" id="apidoc.element.regenerator.types.builders.typeCastStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>typeCastStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeCastStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.typeParameter" id="apidoc.element.regenerator.types.builders.typeParameter">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>typeParameter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeParameter = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.typeParameterDeclaration" id="apidoc.element.regenerator.types.builders.typeParameterDeclaration">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>typeParameterDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeParameterDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.typeParameterInstantiation" id="apidoc.element.regenerator.types.builders.typeParameterInstantiation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>typeParameterInstantiation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeParameterInstantiation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.typeofTypeAnnotation" id="apidoc.element.regenerator.types.builders.typeofTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>typeofTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeofTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.unaryExpression" id="apidoc.element.regenerator.types.builders.unaryExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>unaryExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unaryExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.unaryStatement" id="apidoc.element.regenerator.types.builders.unaryStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>unaryStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unaryStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.unionTypeAnnotation" id="apidoc.element.regenerator.types.builders.unionTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>unionTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unionTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.updateExpression" id="apidoc.element.regenerator.types.builders.updateExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>updateExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.updateStatement" id="apidoc.element.regenerator.types.builders.updateStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>updateStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.variableDeclaration" id="apidoc.element.regenerator.types.builders.variableDeclaration">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>variableDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">variableDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.variableDeclarator" id="apidoc.element.regenerator.types.builders.variableDeclarator">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>variableDeclarator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">variableDeclarator = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.voidTypeAnnotation" id="apidoc.element.regenerator.types.builders.voidTypeAnnotation">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>voidTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">voidTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.whileStatement" id="apidoc.element.regenerator.types.builders.whileStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>whileStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">whileStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.withStatement" id="apidoc.element.regenerator.types.builders.withStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>withStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.yieldExpression" id="apidoc.element.regenerator.types.builders.yieldExpression">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>yieldExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">yieldExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.types.builders.yieldStatement" id="apidoc.element.regenerator.types.builders.yieldStatement">
        function <span class="apidocSignatureSpan">regenerator.types.builders.</span>yieldStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">yieldStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regenerator.util" id="apidoc.module.regenerator.util">module regenerator.util</a></h1>


    <h2>
        <a href="#apidoc.element.regenerator.util.defaults" id="apidoc.element.regenerator.util.defaults">
        function <span class="apidocSignatureSpan">regenerator.util.</span>defaults
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (obj) {
  var len = arguments.length;
  var extension;

  for (var i = 1; i &lt; len; ++i) {
    if ((extension = arguments[i])) {
      for (var key in extension) {
        if (hasOwn.call(extension, key) &amp;&amp; !hasOwn.call(obj, key)) {
          obj[key] = extension[key];
        }
      }
    }
  }

  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  plugins: ["*", "jsx", "flow"]
}
};

function compile(source, options) {
var result;

options = utils.<span class="apidocCodeKeywordSpan">defaults</span>(options || {}, {
  includeRuntime: false
});

// Shortcut: Transform only if generators or async functions present.
if (genOrAsyncFunExp.test(source)) {
  result = require("babel-core").transform(source, transformOptions);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.util.isReference" id="apidoc.element.regenerator.util.isReference">
        function <span class="apidocSignatureSpan">regenerator.util.</span>isReference
        <span class="apidocSignatureSpan">(path, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isReference = function (path, name) {
  var node = path.value;

  if (!n.Identifier.check(node)) {
    return false;
  }

  if (name &amp;&amp; node.name !== name) {
    return false;
  }

  var parent = path.parent.value;

  switch (parent.type) {
  case "VariableDeclarator":
    return path.name === "init";

  case "MemberExpression":
    return path.name === "object" || (
      parent.computed &amp;&amp; path.name === "property"
    );

  case "FunctionExpression":
  case "FunctionDeclaration":
  case "ArrowFunctionExpression":
    if (path.name === "id") {
      return false;
    }

    if (path.parentPath.name === "params" &amp;&amp;
        parent.params === path.parentPath.value &amp;&amp;
        parent.params[path.name] === node) {
      return false;
    }

    return true;

  case "ClassDeclaration":
  case "ClassExpression":
    return path.name !== "id";

  case "CatchClause":
    return path.name !== "param";

  case "Property":
  case "MethodDefinition":
    return path.name !== "key";

  case "ImportSpecifier":
  case "ImportDefaultSpecifier":
  case "ImportNamespaceSpecifier":
  case "LabeledStatement":
    return false;

  default:
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regenerator.util.runtimeProperty" id="apidoc.element.regenerator.util.runtimeProperty">
        function <span class="apidocSignatureSpan">regenerator.util.</span>runtimeProperty
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">runtimeProperty = function (name) {
  return b.memberExpression(
    b.identifier("regeneratorRuntime"),
    b.identifier(name),
    false
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regenerator.visit" id="apidoc.module.regenerator.visit">module regenerator.visit</a></h1>


    <h2>
        <a href="#apidoc.element.regenerator.visit.transform" id="apidoc.element.regenerator.visit.transform">
        function <span class="apidocSignatureSpan">regenerator.visit.</span>transform
        <span class="apidocSignatureSpan">(node, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transform(node, options) {
  options = util.defaults(options || {}, {
    includeRuntime: false
  });

  var result = require("babel-core").transformFromAst(node, null, {
    presets: [require("regenerator-preset")],
    code: false,
    ast: true
  });

  node = result.ast;

  if (options.includeRuntime === true) {
    injectRuntime(n.File.check(node) ? node.program : node);
  }

  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).code;
```

AST transformation:
```js
var recast = require("recast");
var ast = recast.parse(es6Source);
ast = require("regenerator").<span class="apidocCodeKeywordSpan">transform</span>(ast);
var es5Source = recast.print(ast);
```

How can you get involved?
---

The easiest way to get involved is to look for buggy examples using [the
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>